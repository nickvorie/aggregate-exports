/* eslint-disable max-len */
/* eslint-disable no-use-before-define */
import path from "path";
import async from "async";
import fs from "fs";
import { promisify } from "util";

import { timer } from "@/lib/util/timer";
import { search } from "@/lib/util/search";
import { groupByDirectory, parentDir } from "@/lib/util/paths";
import { parseFiles } from "@/lib/util/parser";

import { PathResolver, mappings } from "@/lib/PathResolver";
import { OutputMode } from "@/modes";
import { isExportFile, exportFileComment, eslintComment } from "@/lib/util/util";

export type options = {
	pattern: string;
	root: string;
	base: string;
	dryRun: boolean;

	verbose: boolean;

	parse: {
		files: number;
	}

	mappings?: mappings;

	output: {
		mode: OutputMode;
		file: string;
		ignoreWarnings: boolean;
		stripExtention: boolean;
	}
};


export async function generate(options: options) {
	timer.start("run");

	try {
		const resolver = new PathResolver(options.root, options.base, options.mappings, options.output.stripExtention);

		if (options.verbose) {
			console.log("resolver", resolver);
		}

		timer.start("search");

		const filePaths = await search(options.pattern, options.root);

		if (options.verbose) {
			console.log("found", filePaths.length, "files in", `${timer.end("search")}ms`);
		}

		if (!filePaths.length) {
			throw new Error("no paths matched");
		}

		timer.start("parse");

		const files = await parseFiles(filePaths, options.parse.files);

		if (options.verbose) {
			console.log("parsed", filePaths.length, "files in", `${timer.end("parse")}ms`);
		}

		if (!files.length) {
			throw new Error("no valid files parsed");
		}

		let generatedFiles = 0;

		timer.start("generate");

		if (options.output.mode === OutputMode.SINGLE) {
			// Generate one aggregated export file for all target files
			const outputFilePath = path.join(resolver.base, options.output.file);

			// Navigate one step up in the file tree due to the last file path segment being the output file
			const from = parentDir(outputFilePath);

			const exports = files.map((file) => file.getExportString(resolver, from));
			const result = await writeExportFile(outputFilePath, exports);

			if (result) {
				generatedFiles++;
			}
		} else if (options.output.mode === OutputMode.DIRECTORY) {
			// Generate one aggregated export file for each directory containing target files
			const grouped = groupByDirectory(filePaths);

			await async.forEach(Object.keys(grouped), async (directory) => {
				const groupedFiles = files.filter((file) => grouped[directory].includes(file.absolutePath));

				if (!groupedFiles.length) {
					return;
				}

				const exports = groupedFiles.map((file) => file.getExportString(resolver, directory));
				const result = await writeExportFile(path.join(directory, options.output.file), exports);

				if (result) {
					generatedFiles++;
				}
			});
		} else {
			throw new Error(`invalid mode: ${options.output.mode}`);
		}

		if (options.verbose) {
			console.log("generated", generatedFiles, "aggregate export file(s) in", `${timer.end("generate")}ms`);
		}
	} catch (error) {
		console.error(error);
	}

	console.log("completed in", `${timer.end("run")}ms`);

	async function writeExportFile(file: string, exports: string[]) {
		const contents = [
			exportFileComment,
			eslintComment,
		].concat(exports).filter((line) => line).join("\n");

		const exists = await promisify(fs.exists)(file);
		let isAggregateExportFile = false;

		if (exists) {
			isAggregateExportFile = await isExportFile(file);
		}

		if (options.dryRun) {
			console.log();

			if (exists && !isAggregateExportFile) {
				console.warn("THE FOLLOWING FILE EXISTS ALREADY AND WAS NOT GENERATED BY AGGREGATE-EXPORTS");
			}

			console.log(`${file}:`);
			console.log(contents);
			console.log();
		} else {
			if (exists && !isAggregateExportFile && !options.output.ignoreWarnings) {
				console.warn(`skipping pre-existing file: ${file}, to ignore this warning run with -i`);
				return false;
			}

			await promisify(fs.writeFile)(file, contents);
		}

		return true;
	}
}
