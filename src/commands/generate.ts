/* eslint-disable max-len */
/* eslint-disable no-use-before-define */
import path from "path";
import async from "async";
import fs from "fs";
import { promisify } from "util";

import { timer } from "@/lib/util/timer";
import { search } from "@/lib/util/search";
import { parseFiles } from "@/lib/util/parser";

import { Paths, mappings } from "@/lib/paths";
import { OutputFileMode } from "@/modes";
import { isExportFile, exportFileComment } from "@/lib/util/util";

export type options = {
	pattern: string;
	root: string;
	base: string;
	dryRun: boolean;

	verbose: boolean;

	parse: {
		files: number;
	}

	mappings?: mappings;
	stripExtention: boolean;

	output: {
		mode: OutputFileMode;
		file: string;
		ignoreWarnings: boolean;
	}
};


export async function generate(options: options) {
	timer.start("run");

	try {
		const resolver = new Paths(options.root, options.base, options.mappings);

		if (options.verbose) {
			console.log("resolver", resolver);
		}

		timer.start("search");

		const filePaths = await search(options.pattern, options.root);

		if (options.verbose) {
			console.log("found", filePaths.length, "files in", `${timer.end("search")}ms`);
		}

		if (!filePaths.length) {
			throw new Error("no paths matched");
		}

		timer.start("parse");

		const files = await parseFiles(filePaths, options.parse.files);

		if (options.verbose) {
			console.log("parsed", filePaths.length, "files in", `${timer.end("parse")}ms`);
		}

		if (!files.length) {
			throw new Error("no valid files parsed");
		}

		let generatedFiles = 0;

		timer.start("generate");

		if (options.output.mode === OutputFileMode.SINGLE) {
			// TODO implement single-file mode
		} else if (options.output.mode === OutputFileMode.DIRECTORY) {
			const grouped = Paths.groupByDirectory(filePaths);

			await async.forEach(Object.keys(grouped), async (directory) => {
				const groupedFiles = files.filter((file) => grouped[directory].includes(file.absolutePath));

				if (!groupedFiles.length) {
					return;
				}

				timer.start(`resolve.${directory}`);

				const exports = groupedFiles.map((file) => file.getExportString(resolver));

				const duration = timer.end(`resolve.${directory}`);

				if (options.verbose) {
					console.log("resolved", exports.length, "exports for", resolver.getMappedPath(directory).source, `(${groupedFiles.length} files) in ${duration}ms`);
				}

				const result = await writeExportFile(path.join(directory, options.output.file), exports);

				if (result) {
					generatedFiles++;
				}
			});
		}

		if (options.verbose) {
			console.log("generated", generatedFiles, "aggregate export file(s) in", `${timer.end("generate")}ms`);
		}
	} catch (error) {
		console.error(error);
	}

	console.log("completed in", `${timer.end("run")}ms`);

	async function writeExportFile(file: string, exports: string[]) {
		const contents = [
			exportFileComment,
			"/* eslint-disable */",
		].concat(exports).filter((line) => line).join("\n");

		const exists = await promisify(fs.exists)(file);
		let isAggregateExportFile = false;

		if (exists) {
			isAggregateExportFile = await isExportFile(file);
		}

		if (options.dryRun) {
			console.log();

			if (exists && !isAggregateExportFile) {
				console.warn("THE FOLLOWING FILE EXISTS ALREADY AND WAS NOT GENERATED BY THIS PROGRAM");
			}

			console.log(`${file}:`);
			console.log(contents);
			console.log();
		} else {
			if (exists && !isAggregateExportFile && !options.output.ignoreWarnings) {
				console.warn(`skipping pre-existing file: ${file}, to ignore this warning run with -i`);
				return false;
			}

			await promisify(fs.writeFile)(file, contents);
		}

		return true;
	}
}
